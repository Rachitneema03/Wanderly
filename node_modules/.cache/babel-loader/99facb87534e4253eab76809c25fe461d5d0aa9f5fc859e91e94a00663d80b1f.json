{"ast":null,"code":"// Location Service for Wanderly\nexport class LocationService {\n  constructor() {\n    this.currentLocation = null;\n    this.watchId = null;\n  }\n\n  // Get current user location\n  async getCurrentLocation() {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported by this browser.'));\n        return;\n      }\n      const options = {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 300000 // 5 minutes\n      };\n      navigator.geolocation.getCurrentPosition(position => {\n        const location = {\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude,\n          accuracy: position.coords.accuracy,\n          timestamp: position.timestamp\n        };\n        this.currentLocation = location;\n        resolve(location);\n      }, error => {\n        let errorMessage = 'Unable to retrieve your location.';\n        switch (error.code) {\n          case error.PERMISSION_DENIED:\n            errorMessage = 'Location access denied by user.';\n            break;\n          case error.POSITION_UNAVAILABLE:\n            errorMessage = 'Location information is unavailable.';\n            break;\n          case error.TIMEOUT:\n            errorMessage = 'Location request timed out.';\n            break;\n          default:\n            errorMessage = 'An unknown error occurred while retrieving location.';\n            break;\n        }\n        reject(new Error(errorMessage));\n      }, options);\n    });\n  }\n\n  // Watch location changes\n  watchLocation(callback) {\n    if (!navigator.geolocation) {\n      throw new Error('Geolocation is not supported by this browser.');\n    }\n    const options = {\n      enableHighAccuracy: true,\n      timeout: 10000,\n      maximumAge: 300000\n    };\n    this.watchId = navigator.geolocation.watchPosition(position => {\n      const location = {\n        latitude: position.coords.latitude,\n        longitude: position.coords.longitude,\n        accuracy: position.coords.accuracy,\n        timestamp: position.timestamp\n      };\n      this.currentLocation = location;\n      callback(location);\n    }, error => {\n      console.error('Location watch error:', error);\n      callback(null, error);\n    }, options);\n    return this.watchId;\n  }\n\n  // Stop watching location\n  stopWatchingLocation() {\n    if (this.watchId) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n    }\n  }\n\n  // Get location name from coordinates (reverse geocoding)\n  async getLocationName(latitude, longitude) {\n    try {\n      const response = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${latitude}&longitude=${longitude}&localityLanguage=en`);\n      if (!response.ok) {\n        throw new Error('Failed to fetch location name');\n      }\n      const data = await response.json();\n      return {\n        city: data.city || data.locality,\n        country: data.countryName,\n        region: data.principalSubdivision,\n        fullName: `${data.city || data.locality}, ${data.countryName}`\n      };\n    } catch (error) {\n      console.error('Error getting location name:', error);\n      return {\n        city: 'Unknown',\n        country: 'Unknown',\n        region: 'Unknown',\n        fullName: 'Unknown Location'\n      };\n    }\n  }\n\n  // Calculate distance between two coordinates (in kilometers)\n  calculateDistance(lat1, lon1, lat2, lon2) {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = this.deg2rad(lat2 - lat1);\n    const dLon = this.deg2rad(lon2 - lon1);\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c;\n    return distance;\n  }\n\n  // Convert degrees to radians\n  deg2rad(deg) {\n    return deg * (Math.PI / 180);\n  }\n\n  // Check if location services are available\n  isLocationAvailable() {\n    return 'geolocation' in navigator;\n  }\n\n  // Request location permission\n  async requestLocationPermission() {\n    if (!this.isLocationAvailable()) {\n      throw new Error('Geolocation is not supported by this browser.');\n    }\n    try {\n      const permission = await navigator.permissions.query({\n        name: 'geolocation'\n      });\n      return permission.state === 'granted';\n    } catch (error) {\n      // Fallback: try to get location and see if it works\n      try {\n        await this.getCurrentLocation();\n        return true;\n      } catch (error) {\n        return false;\n      }\n    }\n  }\n\n  // Get cached location if available\n  getCachedLocation() {\n    return this.currentLocation;\n  }\n\n  // Clear cached location\n  clearCachedLocation() {\n    this.currentLocation = null;\n  }\n}\n\n// Create a singleton instance\nexport const locationService = new LocationService();\n\n// Note: React hooks should be defined in React components, not in service files\n// If you need location hooks, create them in your React components using this service","map":{"version":3,"names":["LocationService","constructor","currentLocation","watchId","getCurrentLocation","Promise","resolve","reject","navigator","geolocation","Error","options","enableHighAccuracy","timeout","maximumAge","getCurrentPosition","position","location","latitude","coords","longitude","accuracy","timestamp","error","errorMessage","code","PERMISSION_DENIED","POSITION_UNAVAILABLE","TIMEOUT","watchLocation","callback","watchPosition","console","stopWatchingLocation","clearWatch","getLocationName","response","fetch","ok","data","json","city","locality","country","countryName","region","principalSubdivision","fullName","calculateDistance","lat1","lon1","lat2","lon2","R","dLat","deg2rad","dLon","a","Math","sin","cos","c","atan2","sqrt","distance","deg","PI","isLocationAvailable","requestLocationPermission","permission","permissions","query","name","state","getCachedLocation","clearCachedLocation","locationService"],"sources":["D:/PROJECTS/Openai Hackathon/Wanderly/src/components/LocationService.js"],"sourcesContent":["// Location Service for Wanderly\nexport class LocationService {\n  constructor() {\n    this.currentLocation = null;\n    this.watchId = null;\n  }\n\n  // Get current user location\n  async getCurrentLocation() {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported by this browser.'));\n        return;\n      }\n\n      const options = {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 300000 // 5 minutes\n      };\n\n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          const location = {\n            latitude: position.coords.latitude,\n            longitude: position.coords.longitude,\n            accuracy: position.coords.accuracy,\n            timestamp: position.timestamp\n          };\n          \n          this.currentLocation = location;\n          resolve(location);\n        },\n        (error) => {\n          let errorMessage = 'Unable to retrieve your location.';\n          \n          switch (error.code) {\n            case error.PERMISSION_DENIED:\n              errorMessage = 'Location access denied by user.';\n              break;\n            case error.POSITION_UNAVAILABLE:\n              errorMessage = 'Location information is unavailable.';\n              break;\n            case error.TIMEOUT:\n              errorMessage = 'Location request timed out.';\n              break;\n            default:\n              errorMessage = 'An unknown error occurred while retrieving location.';\n              break;\n          }\n          \n          reject(new Error(errorMessage));\n        },\n        options\n      );\n    });\n  }\n\n  // Watch location changes\n  watchLocation(callback) {\n    if (!navigator.geolocation) {\n      throw new Error('Geolocation is not supported by this browser.');\n    }\n\n    const options = {\n      enableHighAccuracy: true,\n      timeout: 10000,\n      maximumAge: 300000\n    };\n\n    this.watchId = navigator.geolocation.watchPosition(\n      (position) => {\n        const location = {\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude,\n          accuracy: position.coords.accuracy,\n          timestamp: position.timestamp\n        };\n        \n        this.currentLocation = location;\n        callback(location);\n      },\n      (error) => {\n        console.error('Location watch error:', error);\n        callback(null, error);\n      },\n      options\n    );\n\n    return this.watchId;\n  }\n\n  // Stop watching location\n  stopWatchingLocation() {\n    if (this.watchId) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n    }\n  }\n\n  // Get location name from coordinates (reverse geocoding)\n  async getLocationName(latitude, longitude) {\n    try {\n      const response = await fetch(\n        `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${latitude}&longitude=${longitude}&localityLanguage=en`\n      );\n      \n      if (!response.ok) {\n        throw new Error('Failed to fetch location name');\n      }\n      \n      const data = await response.json();\n      return {\n        city: data.city || data.locality,\n        country: data.countryName,\n        region: data.principalSubdivision,\n        fullName: `${data.city || data.locality}, ${data.countryName}`\n      };\n    } catch (error) {\n      console.error('Error getting location name:', error);\n      return {\n        city: 'Unknown',\n        country: 'Unknown',\n        region: 'Unknown',\n        fullName: 'Unknown Location'\n      };\n    }\n  }\n\n  // Calculate distance between two coordinates (in kilometers)\n  calculateDistance(lat1, lon1, lat2, lon2) {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = this.deg2rad(lat2 - lat1);\n    const dLon = this.deg2rad(lon2 - lon1);\n    const a = \n      Math.sin(dLat/2) * Math.sin(dLat/2) +\n      Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) * \n      Math.sin(dLon/2) * Math.sin(dLon/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    const distance = R * c;\n    return distance;\n  }\n\n  // Convert degrees to radians\n  deg2rad(deg) {\n    return deg * (Math.PI/180);\n  }\n\n  // Check if location services are available\n  isLocationAvailable() {\n    return 'geolocation' in navigator;\n  }\n\n  // Request location permission\n  async requestLocationPermission() {\n    if (!this.isLocationAvailable()) {\n      throw new Error('Geolocation is not supported by this browser.');\n    }\n\n    try {\n      const permission = await navigator.permissions.query({ name: 'geolocation' });\n      return permission.state === 'granted';\n    } catch (error) {\n      // Fallback: try to get location and see if it works\n      try {\n        await this.getCurrentLocation();\n        return true;\n      } catch (error) {\n        return false;\n      }\n    }\n  }\n\n  // Get cached location if available\n  getCachedLocation() {\n    return this.currentLocation;\n  }\n\n  // Clear cached location\n  clearCachedLocation() {\n    this.currentLocation = null;\n  }\n}\n\n// Create a singleton instance\nexport const locationService = new LocationService();\n\n// Note: React hooks should be defined in React components, not in service files\n// If you need location hooks, create them in your React components using this service\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}